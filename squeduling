squeduling for real-time systems:
=================================

we want to comply with time constrictions and functionality constrictions.

The schedule orginaize the tastk for try to comply with the above requirements.

So we can find, several task status:

- Ready state: It's not executed at the moment, but it is such a state, that can start exectution, when the sckedule, signals it.
  
- Running state: When the sckquedule tast is Ready, and is selected for execution, it start its action, and now is Running.

- Blocked state: When a Running Task is running, it can be blocked for several reasons. That means that this task is not running any
more, and cannot be squeduled at the next squeduling point. This can happen, when that Task is in a delay, waiting data to be send, or
receiving data. When the delay runs out, then the Task, moves its state to Ready Task, and it can be scheduled again.

Â¿Can a Task, put another Task in Blocked state? - Yes.

-Suspensiton state: Another state, is the Suspension of a task, if the user or the systme, consider that this task should not be scheduled
again. 


A squedule that never looses a death line is call FEASEABLE, this depends on its schedule algorithm.

Scheduling example:


|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|----->
0     1     2     3     4     5     6     7     8     9     10

And three tasts: T1, T2 and T3:


T - task
T1 -task 1. time(T1) = 1
T2 -task 2. time(T2) = 0.5
T3 -task 3. time(T3) = 3

 ____    __     ________________
|    |  |  |   |                |
| T1 |  |T2|   |      T3        |
|____|  |__|   |________________|


With the deathlines acording to the figure below:


D - death-line
D1 -death-line task1 = 2
D2 -death-line tast2 = 2.5
D3 -death-line tast3 = 5

           D1 D2             D3
            |  |              |
            V  V              V
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|----->
0     1     2     3     4     5     6     7     8     9     10


The schedule may want to allocate the T3, the first, because it might be the most important one:



           D1 D2             D3
            |  |              |
            V  V              V
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|----->
0     1     2     3     4     5     6     7     8     9     10
 ________________ ____ __  
|                |    |  |
|      T3        | T1 |T2|  
|________________|____|__|

- but, by doing so, we make the Task1, and Task2, miss their death lines.

This squeduler is not feaseble, even thougth Task3, might be the most important task.

But if we change the squedule, so it choose first T1, and then T2, and then T3, we see:

           D1 D2             D3
            |  |              |
            V  V              V
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|----->
0     1     2     3     4     5     6     7     8     9     10
 __________________________ 
|    |  |                  |
| T1 |T2|        T3        |          
|____|__|__________________|

 
Then all three task meet their deathlines.

So now our sistema has became feaseble!!

In many sistems, is not just order the possible tast, but you have to take into account the relationship between tasks, because 
ones can be dependant of the results of others tastks.- This states the problem of priority of tasks, - and sometime we found the 
problem of priority inversion :S ... if we are not careful.


PRE-EMPTIVE SYSTESM:

 In a Job is running, and is stoped, for running another job, and then it is call again, and it continues, where it have stoped, then
 this schedule type is known as a pre-emptive system.
 
 So a PRE-EMPTIVE SYSTEM is that one that can stop the current process, perfom another second process, and then again, continue the fist
 process, where it was left.
 
 For a scheduler to be pre-emptive, the scheduler must be able to save the current status of the actual task, and then switch to another
 task.
 
 The process of switching context, usually is triggered by a timer, provided by de OS, when the timer triggers the interrupt, this makes
 the OS, run a routine call, __IRS__(), first thing it does is block the interrupts, so nothing can change its process. Then it stores
 the regitsters, to the task stack -using architecture specific, assembly code- 
 
 Void __ISR__(){
 cli(); //disable interrupts
 stores_context(); 
 next_job();
 load_context();
 sei(); //enable interrupts
 reti(); //return
 }
 
 Then the schedule decides on what will be the next task, and then loads the context back to the new task, because this was saved
 last time the task was interrumped. Now the system is ready to continue executing.the OS enables interrupts again, and then returns
 from the ISR.
 
 This procedure of context switch, takes some time, and is refered as the "Context Switch overhead", and must be taken into account,
 when planning a real-time system and its timeline.
 
 










