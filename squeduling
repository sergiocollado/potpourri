squeduling for real-time systems:
=================================

we want to comply with time constrictions and functionality constrictions.

The schedule orginaize the tastk for try to comply with the above requirements.

So we can find, several task status:

- Ready state: It's not executed at the moment, but it is such a state, that can start exectution, when the sckedule, signals it.
  
- Running state: When the sckquedule tast is Ready, and is selected for execution, it start its action, and now is Running.

- Blocked state: When a Running Task is running, it can be blocked for several reasons. That means that this task is not running any
more, and cannot be squeduled at the next squeduling point. This can happen, when that Task is in a delay, waiting data to be send, or
receiving data. When the delay runs out, then the Task, moves its state to Ready Task, and it can be scheduled again.

Â¿Can a Task, put another Task in Blocked state? - Yes.

-Suspensiton state: Another state, is the Suspension of a task, if the user or the systme, consider that this task should not be scheduled
again. 


A squedule that never looses a death line is call FEASEABLE, this depends on its schedule algorithm.

Scheduling example:


|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|----->

0     1     2     3     4     5     6     7     8     9     10

And three tasts: T1, T2 and T3:


T - task
T1 -task 1. time(T1) = 1
T2 -task 2. time(T2) = 0.5
T3 -task 3. time(T3) = 3

 ____    __     ________________
|    |  |  |   |                |
| T1 |  |T2|   |      T3        |
|____|  |__|   |________________|


With the deathlines acording to the figure below:


D - death-line
D1 -death-line task1 = 2
D2 -death-line tast2 = 2.5
D3 -death-line tast3 = 5

           D1 D2             D3
            |  |              |
            V  V              V
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|----->
0     1     2     3     4     5     6     7     8     9     10


The schedule may want to allocate the T3, the first, because it might be the most important one:



           D1 D2             D3
            |  |              |
            V  V              V
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|----->
0     1     2     3     4     5     6     7     8     9     10
 ________________ ____ __  
|                |    |  |
|      T3        | T1 |T2|  
|________________|____|__|

- but, by doing so, we make the Task1, and Task2, miss their death lines.

This squeduler is not feaseble, even thougth Task3, might be the most important task.

But if we change the squedule, so it choose first T1, and then T2, and then T3, we see:

           D1 D2             D3
            |  |              |
            V  V              V
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|----->
0     1     2     3     4     5     6     7     8     9     10
 __________________________ 
|    |  |                  |
| T1 |T2|        T3        |          
|____|__|__________________|

 
Then all three task meet their deathlines.

So now our sistema has became feaseble!!

In many sistems, is not just order the possible tast, but you have to take into account the relationship between tasks, because 
ones can be dependant of the results of others tastks.- This states the problem of priority of tasks, - and sometime we found the 
problem of priority inversion :S ... if we are not careful.


PRE-EMPTIVE SYSTESM:

 In a Job is running, and is stoped, for running another job, and then it is call again, and it continues, where it have stoped, then
 this schedule type is known as a pre-emptive system.
 
 So a PRE-EMPTIVE SYSTEM is that one that can stop the current process, perfom another second process, and then again, continue the fist
 process, where it was left.
 
 For a scheduler to be pre-emptive, the scheduler must be able to save the current status of the actual task, and then switch to another
 task.
 
 The process of switching context, usually is triggered by a timer, provided by de OS, when the timer triggers the interrupt, this makes
 the OS, run a routine call, __IRS__(), first thing it does is block the interrupts, so nothing can change its process. Then it stores
 the regitsters, to the task stack -using architecture specific, assembly code- 
 
 Void __ISR__(){
 cli(); //disable interrupts
 stores_context(); 
 next_job();
 load_context();
 sei(); //enable interrupts
 reti(); //return
 }
 
 Then the schedule decides on what will be the next task, and then loads the context back to the new task, because this was saved
 last time the task was interrumped. Now the system is ready to continue executing.the OS enables interrupts again, and then returns
 from the ISR.
 
 This procedure of context switch, takes some time, and is refered as the "Context Switch overhead", and must be taken into account,
 when planning a real-time system and its timeline.
 
 




Poor-mans profiler:
-------------------

Profile a program, means to measure it performance, that is to say, it time execution (mostly)

CPU time measurement:
---------------------

CPU Time, is the CPU used time relative to a process, that is the amount of time that a certain process is using, of the CPU;
take into account, that if several process, are running in parallel, each one will use the CPU certain amount of time, that
depends on the operating system process squeduler.

If you want to check the time it takes a function from begining to end; then you can use the following `stdlib` function:

With the header file **'times.h'** or **'sys/times.h'**, you can use the function **`'clock()'`**, this will return a struct with the 
number of ticks of the clock for the current process. For using this function, you have to call it at the start of the period
you want to measure, and at the end of it; Then, substract the **'start'** and **'end'** clocks, and ,divide it by the number of 
clock ticks per second (defined in the macro: **`CLOCKS_PER_SEC`**, or the 'sysconf' **`_SC_CLK_TCK_`**), to get the processor time.

Example:

```C
#include <time.h>

clock_t start, end;
double cpu_time_used;

...

start = clock();

... // process data or else...

end = clock();

cpu_time_used = ((double)(end-start)/CLOCKS_PER_SEC);

```

Watch out: 

Take into account, that different computers, and operating systems have different resolutions, and different methods to 
track time.

If the clock() cant give you a result or it is not available, it returns the value '(clock_t)(-1)'.

There is an old macro: `'int **CLK_TCK**'` - don't use it. Use a newer one.

Portability Note: The clock function described in CPU Time is specified by the ISO C standard

reference: </br>
https://www.gnu.org/software/libc/manual/html_node/Time-Basics.html#Time-Basics </br>
https://www.gnu.org/software/libc/manual/html_node/CPU-Time.html#CPU-Time </br>

time interval measurement:
-------------------------

With the header file **'times.h'** or **'sys/times.h'**, if you want to measure some time interval, you can use the function:

>'clock_t **times(struct tms *buffer)'

The times function stores the processor time information for the calling process in buffer. Remeber 'clock_t' are the clock ticks.

the tms struct, contains at least the following fields:

- **clock_t tms_utime** - This is the total processor time the calling process has used in executing the instructions of its program.

- **clock_t tms_stime** - This is the processor time the system has used on behalf of the calling process.

- **clock_t tms_cutime** -In other words, it represents the total processor time used in executing the instructions of all the terminated child processes of the
calling process, excluding child processes which have not yet been reported by `'wait'` or `'waitpid'`.

- **clock_t tms_cstime** - This is similar to tms_cutime, but represents the total processor time the system has used on behalf of all the terminated child processes of the calling process.
terminated child processes of the calling process, excluding child processes which have not yet been reported by wait or waitpid.

**Macros**: defined in the macros: **`CLOCKS_PER_SEC`**, or the 'sysconf' **`_SC_CLK_TCK_`**. There is an old macro: `'int **CLK_TCK**'` - don't use it. Use a newer one.

**Portability Note**: The clock function described in CPU Time is specified by the ISO C standard. The times function is a feature of POSIX.1.
On GNU systems, the CPU time is defined to be equivalent to the sum of the tms_utime and tms_stime fields returned by times.

references:
https://www.gnu.org/software/libc/manual/html_node/Time-Basics.html#Time-Basics </br>
https://www.gnu.org/software/libc/manual/html_node/Processor-Time.html#Processor-Time </br>

Supervision of programs:
-----------------------

It is easy to use an 'watchdog' daemon. The term 'watchdog' is usually refered and used to a mechanism that reset/reboots the
process/progra/system if it detects that someaow is not running correctly or have stall at some point. Its a safe measurement.


references:
https://linux.die.net/man/8/watchdog
https://linux.die.net/man/8/wd_keepalive
https://linux.die.net/man/8/checkquorum
https://linux.die.net/man/8/wdmd
https://linux.die.net/man/8/wdmd_selinux



























