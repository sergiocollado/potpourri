# Notes on Linux interrupt and bottom halves


## Interrupts 

- reference: https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html
- reference: https://en.wikipedia.org/wiki/Interrupt_vector_table
- reference: https://en.wikipedia.org/wiki/Interrupt_handler
- reference: https://tldp.org/HOWTO/Plug-and-Play-HOWTO-7.html
- reference: https://people.freebsd.org/~jhb/papers/bsdcan/2007/article/article.html
- reference: https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller
- reference: https://elixir.bootlin.com/linux/v6.5.7/source/include/linux/interrupt.h
- reference: https://elixir.bootlin.com/linux/v6.5.7/source/arch/x86/kernel/irq.c
- reference: https://linux.die.net/HOWTO/KernelAnalysis-HOWTO.html#toc1


### What is an interrupt?

An interrupt is an input signal to the processor, sent by the hardware peripherals when they need processor attention. 

### What is the purpose of the interrupts?

For example, if we want to perform an action with an incomming packet from the network card as soon as the packet arrives.

If you don't want to continously ask the network card "has any packet arrive yet?" and waste processor time, you
can use external hardware interrupt IRQ

The interrupt line from a device should be connected to the INTR line of the CPU, and after each packet is received,
the network card will make a signal over this line. 

The CPU will sense this line and know that the network card has information for it.

Only after that, the CPU will read the incoming packet. 

### Types of interrupt

1. - Hardware / asynchronous:
     - Generated by hw devices
     - Occours at arbitrary times (asynchronous) with respect to the clock signals
     - Examples: processing of a key on the keyboard, mouse movement, timer fired, network card reporting arrival of a packet...
2. - Software / synchronous:
     - Generated by executing instructions
     - Occorus synchronously with respect to processor clock
     - Also called as exceptions/traps
     - Examples: divide-by-zero, system call, page fault
    
### Exceptions

Exceptions are classified as faults, traps, and abort, depending on the way they are reported and whether the instruction 
that caused the exception can be restared, without loss of programs. 

Traps increment the instruction pointer, faults don't, and aborts "explode". 

- Faults: These can be corrected and the programmer may continue as if nothing happened. Eg. page fault 
- Traps: Traps are reported inmediately after the execution of the trapping instruction. Eg. int instruction
- Aborts: Some severe unrecoverable error. Eg. hardware failure

### General protection Fault

A general protection fault may occur for various reasons, the most common:

- segment error (privilege, type, limit, read/write rights).
- executing priviledged instructions while CPL (current privilege level) is not equal to 0.
- writing a 1 in a reserved register field.
- referencing or accessing a null-descriptor.
- trying to access an unimlemented register (like mov cr6, eax)
- the saved instruction pointer points to the instruction which causes the exception

#### Example 1
So for example for a divide by zero problem:

```c
  // divide_by_zero.c
  1 #include <stdio.h>                                                               
  2                                                                                  
  3 int main()                                                                       
  4 {                                                                                
  5 »       int i = 1/0;                                                             
  6 »       return 0;                                                                
  7 }                                                                                 
```

```bash
sergio@laptop:~/repos/divide-by-zero$ gcc -o div_by_zero.c divide_by_zero.c 
divide_by_zero.c: In function ‘main’:
divide_by_zero.c:5:18: warning: division by zero [-Wdiv-by-zero]
    5 |         int i = 1/0;
      |           
```
what should happen here?

```bash
sergio@laptop:~/repos/divide-by-zero$ ls
div_by_zero.c  divide_by_zero.c
sergio@laptop:~/repos/divide-by-zero$ sudo dmesg -WH &
[1] 6310
sergio@laptop:~/repos/divide-by-zero$ ./div_by_zero.c 
[oct 8 16:43] traps: div_by_zero.c[6315] trap divide error ip:55d9a6c7b13c sp:7ffc0f832c10 error:0 in div_by_zero.c[55d9a6c7b000+1000]
Floating point exception (core dumped)
```

#### Example 2

```c
  //  userapp.c 
  1 #include <stdio.h>                                                               
  2 #include </usr/include/sys/io.h>                                                 
  3                                                                                  
  4 int main()                                                                       
  5 {                                                                                
  6 »       outb(0x80, 0x00);                                                        
  7 »       return 0;                                                                
  8 }   
```

```
sergio@laptop:~/repos/divide-by-zero$ gcc -o userapp userapp.c peers lock
sergio@laptop:~/repos/divide-by-zero$ sudo dmesg -WH &
sergio@laptop:~/repos/divide-by-zero$ ./userapp
[oct 8 19:56] show_signal: 1 callbacks suppressed
[  +0,000006] traps: userapp[4589] general protection fault ip:55c13b8c4140 sp:7fff1bd28c70 error:0 in userapp[55c13b8c4000+1000]
Segmentation fault (core dumped)
```

In this case we are attemping to write to a memory that it is now allow, we don't have access writes, so a general protection fault is triggered.


We can see it should be a fault, but in linux is denominated as a trap. 

### How debuggers work?

To implement breakpoints on the x86 architecture, software interrupts (also known as "traps") are used.

Breakpoints are implemented on the CPU by a special trap called int 3.

`int` is 0x86 jargon for "trap instruction" - a call to a predefined interrupts handler. 

x86 supports the int instruction with a 8-bit operand specifying the number of the interrupt that occurred.

```c
  1 #include <stdio.h>                                                               
  2                                                                                  
  3 int main() {                                                                     
  4 »       int i = 0;                                                               
  5 »       while (i < 6) {                                                          
  6 »       »       printf("i equals to: %d\n", i);                                  
  7 »       »       ++i;                                                             
  8 »       }                                                                        
  9 »       __asm__("int3");                                                         
 10 }                                                                                            
```

```bash
sergio@laptop:~/repos/divide-by-zero$ gcc -o int3 interrupt.c 
sergio@laptop:sudo dmesg -WH &
i equals to: 0
i equals to: 1
i equals to: 2
i equals to: 3
i equals to: 4
i equals to: 5
[  +1,920005] traps: int3[7075] trap int3 ip:55f6a6900182 sp:7ffdc37606c0 error:0 in int3[55f6a6900000+1000]
Trace/breakpoint trap (core dumped)
```

but if we debug the program with gcc: 

```
sergio@laptop:~/repos/divide-by-zero$ gdb ./int3 
GNU gdb (Ubuntu 12.1-3ubuntu2) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./int3...

This GDB supports auto-downloading debuginfo from the following URLs:
https://debuginfod.ubuntu.com 
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
(No debugging symbols found in ./int3)
(gdb) run
Starting program: /home/sergio/repos/divide-by-zero/int3 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
i equals to: 0
i equals to: 1
i equals to: 2
i equals to: 3
i equals to: 4
i equals to: 5

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000555555555182 in main ()
(gdb) 
```
the program was ran, and stoped by itself at the int3 (breakpoint trap)

if we continue the program, it will exit normally:

```
Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000555555555182 in main ()
(gdb) c
Continuing.
[Inferior 1 (process 7187) exited normally]
```

### Hardware interrupt triggering methods

Each interrupt signal input is designed to be triggered by either a logical signal event or particular edge (level transition)

#### Level triggered 

Interrupt is requested by holding the interrupt signal at its particular (high or low) active logic level.
Level triggered interrupts happen as long as the interrupt line is held active level. 

As long as the line, you get interrupt, when you serve the interrupt and return, it the interrupt line is still 
active, you get the interrupt again inmediatelly. 

#### Edge triggered

Interrupt is requested by a level transition on the interrupt line. 
 - Falling edge (high to low)
 - Rising edge (Low to high)

These interrupts are issued per transition and not repeated. E.g. in networking when the packet queue goes from
empty to non-empty. This makes it critical to never miss an edge triggered interrupt, because failure to handle
one interrupt result in no further interrupts from happening. 

### Masking

Processors typically have an internal interrupt mask register. This allows selective enabling and disabling 
of hardware interrupts. 

Each interrupt signal is associated with a bit in the mask register
- Bit = 1, Interrupt enabled
- Bit = 0, Interrupt disabled

When the interrupt is disabled, the associated interrupt signal will be ignored by the processor. 

Maskable interrupts: Interrupts which can be enabled/disabled.

Non maskable interrupts: Interrupts which cannot be disabled. Example: NMI, timeout signal from watchdog timer. 

For example the 8086 processor has two hardware interrupt signals:

- NMI non-maskable interrupt
- INTR Interrupt request (maskable interrupt)

How to support more than two interrupts?

It would be very unproductive to make a ton of INTR pins on the CPU for all of them.

To solve this problem a special chip was invented, the interrupt controller. 

### Programable interrupt controller (PIC) 

The Intel 8259 Programmable Interrupt Controller (PIC) is one of the most important chips making the x86 architecture.

reference: https://en.wikipedia.org/wiki/Intel_8259

It allows multiplexing the single INT line on the x86 processor to multiple interrupts lines.
Interrupt lines can be assigned various hardware priority levels, as well as a programmable interrupt masking.

Each PIC has 8 interrupts lines called Interrupt ReQuests (IRQ), numbered from 0 to 7. 
PIC has one output line which connects the INTR line to the CPU. 

A device supporting interrupts has an output pin used for signalling an Interrupt ReQuest (IRQ)

CPU will know that some devices requires its inmediate attention, and the processor will ask the PIC which 
of the 8 input lines (IRQx) was the source of the interruption.

#### Why call Interrupt ReQuest (IRQ)

Peripheral devices cannot directly force interrupts, but has to request them via the PIC, we call them IRQ
or Interrupt ReQuests. 

#### Dual PIC

Soon 8 lines were not enough. To increase the total number of interrupt lines two 8259 PIC controllers
(master and slave) were connected in cascade (Dual PIC). 

- IRQs from 0 to 7 where processed with the first Intel 8259 PIC (master)
- IRQs from 8 to 15 are processed with the second Intel 8259 PIC (slave)

Only the master is connected to the CPU and can signal about the incomming interrupts.
It there is an interrupt on lines 8-15, the second PIC (slave) will signal about it to the master
on the line IRQ 2, and after that the master will signal the CPU. 

#### Port Interface

Two separate dedicated ports in the x86 IO-port space for each connected PIC

- Master PIC - 0x20, 0x21
- Slave  PIC - 0xA0, 0xA1

```
# sudo cat /proc/ioports | grep -i pic # you really need to use sudo!
```

#### Device interrupt mapping

Devices were initially statically assign, so the assignations were: 


##### Master PIC
- IRQ 0 — system timer
- IRQ 1 — keyboard controller
- IRQ 2 — cascade (interrupt from slave controller)
- IRQ 3 — serial port COM2
- IRQ 4 — serial port COM1
- IRQ 5 — parallel port 2 and 3 or sound card
- IRQ 6 — floppy controller
- IRQ 7 — parallel port 1

##### Slave PIC
- IRQ 8 — RTC timer
- IRQ 9 — ACPI
- IRQ 10 — open/SCSI/NIC
- IRQ 11 — open/SCSI/NIC
- IRQ 12 — mouse controller
- IRQ 13 — math co-processor
- IRQ 14 — ATA channel 1
- IRQ 15 — ATA channel 2

#### Programmable Interrupt Request (PIRQ)

Initially, the x86 used ISA Bus (https://en.wikipedia.org/wiki/Industry_Standard_Architecture).

The PCI bus, later replaced the ISA bus. Unfortunately the number of devices began to exceed the number 15. 
Also instead of the static ISA bus, devices in the PCI bus can be added to the system dynamically. 
Interrupts in the PCI bus can be shared, so it is possible to connect many devices to one interrupt line IRQ. 

In the end, to solve the problem of lack of interrupt lines, it was decided to group interrupts from all 
the PC devices to PIRQ lines (Progammable Interrupt ReQuests). 

For example, suppouse we have 4 free interrupts lines on the PIC controller and 20 PCI devices. 
We can combine interrupts from 5 devices into one PIRQx line, and connect those PIRQx lines to the PIC controller.
In this case if there is an interrupt on the PIRQx lines, the processor will have to ask all the devices 
connected to this line about the interrupt to know who is responsible for it, but in the end it solves 
the problem. 

The device that connects the PCI interrupt lines to PIRQ lines is often called a PIR router. 
This method ensures that PIRQx interrupt lines don't connect to lines with ISA interrupts (since 
this will produce conflicts). System software, such as the BIOS or operating system, is
responsible for programming the interrupt router. 

- reference: https://tldp.org/HOWTO/Plug-and-Play-HOWTO-7.html
- reference: https://people.freebsd.org/~jhb/papers/bsdcan/2007/article/article.html

#### APIC (Advanced PIC)

The PIC method only works for a single processor systems.

PIC can only send interrupts to one CPU, and in a multiprocessor system it is desired to load CPUs in a balanced way.

The solution to this problem was the new APIC interface (Advanced PIC).

It is comprised of two components: 
 - IO-APIC - Interfaces with Devices.
 - LAPIC - the local APIC - Interfaces with CPU.

reference: https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller

##### LAPIC 

Each processor in a multiprocessor system consists on a LAPIC (local APIC). Responsible for: 
- receiving various interrupts requests and delivering them to the processor.
- handling prioritization of interrupts
- sending interrupts to other processors (known as inter processor interrutps or IPIs)

LAPIC can be connected directly to I/O devices via local interrupt inputs (timer, thermal sensor) or
throught IOAPIC via external interrupts. 

LAPIC can generate interrupts due to interrupt requests received from various sources: 
 - IPIs received from other processors.
 - Interrupts coming from LINT or EXTINT

##### I/O PIC

Connects to the devices to allow device interrupt requests to be routed to LAPIC(s).
There can be one or more IOAPIC in the system. Each IOAPIC has 24 interruption lines. 
IOAPIC receives interrupts requests from the devices and sends them to LAPIC(s) based
upon the redirection table entries (RTE) programmed in the IOAPIC. 

Note: to maintain backward compatibility, APIC emulates 8259 PIC. 

###### Detection

The CPUID.01h:EDX[bit 9] flag specifies whether a CPU has a build-in local APIC. 


#### CPUID

CPUID is an x86 opcode which stands for CPU Identification.

The CPUID instruction can be used to retrieve various amount of information about your cpu: 
 - vendor string
 - model number
 - size of the internal caches
 - list of CPU features

```
man 4 cpuid
```

The cpuid driver is not auto-loaded. On modular kernels you might need to use the following 
command to load it explicitly before use: 

```
modprobe cpuid
```

Most of the information in cpuid is reported by the kernel in cooked form either in /proc/cpuinfo

```
cat /proc/cpuinfo | grep - i apicid
```
apicid: An unique ID given to each logical processor upon startup. 

We can check on the system log, the "apic" messages: 

```
sudo dmesg | grep -i apic
```

### What happens when there is an interrupt?

The device asserts IRQ of I/O APIC. 

I/O APIC transfer interrupt to LAPIC. 

LAPIC asserts CPU interrupts.

After current instrucction completes CPU senses interrupt line and obtains the IRQ number from LAPIC, jumps to the interrupt handler. 


### How does the hardware find the interrupt handler? 

#### Interrupt vector (IV)

On x86 each interrupt or exception is identified by a number between 0 and 255. Intel calls this number a vector. 

The interrupt vector is used by the interrupt-handling mechanisms to locate the system-software service routine
assigned to the exception or interrupt.

Up to 256 unique interrupt vectors are available in x86.

The number or interrupt vectors or entry points supported by a CPU differs based on the CPU architecture. 

The first 32 vectors are reserved for predefined exceptions and interrupt conditions. 

Look into arch/x86/include/asm/traps.h. For example: https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/trapnr.h

```
// https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/trapnr.h
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _ASM_X86_TRAPNR_H
#define _ASM_X86_TRAPNR_H

/* Interrupts/Exceptions */

#define X86_TRAP_DE		 0	/* Divide-by-zero */
#define X86_TRAP_DB		 1	/* Debug */
#define X86_TRAP_NMI	 2	/* Non-maskable Interrupt */
#define X86_TRAP_BP		 3	/* Breakpoint */
#define X86_TRAP_OF		 4	/* Overflow */
#define X86_TRAP_BR		 5	/* Bound Range Exceeded */
#define X86_TRAP_UD		 6	/* Invalid Opcode */
#define X86_TRAP_NM		 7	/* Device Not Available */
#define X86_TRAP_DF		 8	/* Double Fault */
#define X86_TRAP_OLD_MF	 9	/* Coprocessor Segment Overrun */
#define X86_TRAP_TS		10	/* Invalid TSS */
#define X86_TRAP_NP		11	/* Segment Not Present */
#define X86_TRAP_SS		12	/* Stack Segment Fault */
#define X86_TRAP_GP		13	/* General Protection Fault */
#define X86_TRAP_PF		14	/* Page Fault */
#define X86_TRAP_SPURIOUS	15	/* Spurious Interrupt */
#define X86_TRAP_MF		16	/* x87 Floating-Point Exception */
#define X86_TRAP_AC		17	/* Alignment Check */
#define X86_TRAP_MC		18	/* Machine Check */
#define X86_TRAP_XF		19	/* SIMD Floating-Point Exception */
#define X86_TRAP_VE		20	/* Virtualization Exception */
#define X86_TRAP_CP		21	/* Control Protection Exception */
#define X86_TRAP_VC		29	/* VMM Communication Exception */
#define X86_TRAP_IRET	32	/* IRET Exception */

#endif
```

#### Interrupt descriptor table (IDT)

The IDT is a linear table of 258 entries which associates an interrupt handler with each interrupt vector. 

When an interrupt is fired, the CPU looks at the IDT table, and finds what method needs to be called. 

Each descriptor is of size 8 bytes (on x86) and 16 bytes (on x86_64)

During early boot, the architecure-specific branch of the kernel code sets up the IDT in memory and programs
the IDTR register (special 0x86 register) of the processor with the physical start address and length of the IDT. 


## Interrupt Handling in Linux Kernel

- reference: https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html#interrupt-handling-in-linux

1. Whenever an interrupt occurs, assembly instructions in linux kernel are executed, which
	locates relevant vector descriptor by multiplying reported vector number by size of vector number(8/16)
	and adding the result to the base address of IDT.

2. common_interrupt: [arch/x86/entry/entry_64.S](https://elixir.bootlin.com/linux/v6.5.7/source/arch/x86/entry/entry_64.S):
	- saves the context of the running process
	- This includes instruction pointer (IP), stack pointer and other registers needed to resume the process again
	- This context is usually saved on the stack.
	- Then the context is changed to interrupt stack.

reference: https://elixir.bootlin.com/linux/v6.5.7/source/arch/x86/entry/entry_64.S

2. Finally it arrives at do_IRQ(). do_IRQ() is the common function for all hardware interrupts

```
	arch/x86/kernel/irq.c
```
reference: https://elixir.bootlin.com/linux/v6.5.7/source/arch/x86/kernel/irq.c

3. Finds IRQ number in saved %EAX register

4. Calls handle_irq which will finally call our registered interrupt handler.

### Interrupt statistics

To check the interrupt statistics: 

```
$ cat /proc/interrupts
```
reference: https://linux.die.net/man/5/proc

/proc/interrupts <br>
This is used to record the number of interrupts per CPU per IO device. Since Linux 2.6.24, for the i386 and x86_64 architectures, at least, this also includes interrupts internal to the system (that is, not associated with a device as such), such as NMI (nonmaskable interrupt), LOC (local timer interrupt), and for SMP systems, TLB (TLB flush interrupt), RES (rescheduling interrupt), CAL (remote function call interrupt), and possibly others. Very easy to read formatting, done in ASCII.

```
$ cat /proc/interrupts

           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       
   0:          2          0          0          0          0          0   IO-APIC    2-edge      timer
   1:        458          0          0          0       6154          0   IO-APIC    1-edge      i8042
   8:          0          0          0          0          0          1   IO-APIC    8-edge      rtc0
   9:          0          0          0          0          0          0   IO-APIC    9-fasteoi   acpi
  12:          0          0          0      22185          0          0   IO-APIC   12-edge      i8042
  14:          0          0          0          0          0          0   IO-APIC   14-edge      ata_piix
  15:          0          0          0          0          0          0   IO-APIC   15-edge      ata_piix
  16:          0      19541          0          0          0          0   IO-APIC   16-fasteoi   vmwgfx, snd_ens1371
  17:       9825          0      47519          0          0          0   IO-APIC   17-fasteoi   ehci_hcd:usb1, i
```

 - Column 1:  IRQ number the file shows only interrupts corresponding to installed handlers

 - Column 2:  counter of the number of interrupts received. A column is present for each processor on the system

 - Column 3/4: Type of the interrupt and device that handles the interrupt.
           -  For x86.
           -  XT-PIC — This is the old AT computer interrupts. 8259
           -  IO-APIC 

 - Column 5:  device associated with this interrupt. This name is supplied by the devname parameter to request_irq(),
            


#### Difference between  IO-APIC-fasteoi and IO-APIC-edge?


The difference lies in the way the interrupts are triggered.

The `-edge` interrupt are edge triggered.

The `-fasteoi` interrupts are level interrupts that are triggered until the interrupt event is acknowledged in the programmable interrupt controller (PIC). 

The EOI stands for End Of Interrupt.

### Watch Interrupts

To see the interrupts occurring on your system, run the command:

```
$ watch -n1 "cat /proc/interrupts"
```

The watch command executes another command periodically, in this case `cat /proc/interrupts`

The `-n1` option tells watch to execute the command every second

`-d` option of watch highlight  the  differences  between successive updates

```
$ watch -n 0.1 -d 'cat /proc/interrupts'
```

`--no-title / -t` option of watch Turn off the header showing the interval, command, and current time at the top of the display, as well as the following blank line.

```
$ watch -n 0.1 -d --no-title 'cat /proc/interrupts'
```

### PCI interrutps 

`lspci` is a utility for displaying information about PCI buses in the system and devices connected to them.

By default, it shows a brief list of devices. Use the options described below to request 
either a more verbose output or output intended for parsing by other programs.

reference: https://man7.org/linux/man-pages/man8/lspci.8.html

```
$ lspci | grep -i Ethernet

$ lspci -s 02:01 -v
```

### Interrupt Handlers


Interrupt handlers are the responsibility of the driver managing the hardware.

If the device uses interrupts, then driver must register one interrupt handler.

#### Registering an interrupt handler

Header File: <linux/interrupt.h>

```
int request_irq(unsigned int irq,
        irq_handler_t handler,
        unsigned long flags,
        const char *name,
        void *dev);
```

#### Parameters:

```
irq     --> The interrupt number being requested
            For some devices,for example legacy PC devices such as the system timer or keyboard, this value is typically hard-coded.
            For most other devices, it is probed or otherwise determined programmatically and dynamically.

handler   --> function pointer to the actual interrupt handler that services this interrupt.
              invoked whenever the operating system receives the interrupt
              typedef irqreturn_t (*irq_handler_t)(int, void *);

flags     --> bitmask of options related to interrupt management.

name      --> Name to be displayed in /proc/interrupts

dev       --> Used for shared Interrupt Lines
```

#### Return Value:

Success  -->    Returns Zero
Failure  -->    Non-Zero Value

```               
void free_irq(unsigned int irq_no, void *dev);
```

When the interrupt is released, using the `free_irq()` function, you must send the same pointer value (dev) along with the same interrupt number (irq_no).


















