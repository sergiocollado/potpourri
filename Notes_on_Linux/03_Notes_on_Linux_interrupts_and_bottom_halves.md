# Notes on Linux interrupt and bottom halves

- reference: https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html#interrupt-handling-in-linux
- reference: https://en.wikipedia.org/wiki/Interrupt_vector_table
- reference: https://en.wikipedia.org/wiki/Interrupt_handler

### What is an interrupt?

An interrupt is an input signal to the processor, sent by the hardware peripherals when they need processor attention. 

### What is the purpose of the interrupts?

For example, if we want to perform an action with an incomming packet from the network card as soon as the packet arrives.

If you don't want to continously ask the network card "has any packet arrive yet?" and waste processor time, you
can use external hardware interrupt IRQ

The interrupt line from a device should be connected to the INTR line of the CPU, and after each packet is received,
the network card will make a signal over this line. 

The CPU will sense this line and know that the network card has information for it.

Only after that, the CPU will read the incoming packet. 

### Types of interrupt

1. - Hardware / asynchronous:
     - Generated by hw devices
     - Occours at arbitrary times (asynchronous) with respect to the clock signals
     - Examples: processing of a key on the keyboard, mouse movement, timer fired, network card reporting arrival of a packet...
2. - Software / synchronous:
     - Generated by executing instructions
     - Occorus synchronously with respect to processor clock
     - Also called as exceptions/traps
     - Examples: divide-by-zero, system call, page fault
    
### Exceptions

Exceptions are classified as faults, traps, and abort, depending on the way they are reported and whether the instruction 
that caused the exception can be restared, without loss of programs. 

Traps increment the instruction pointer, faults don't, and aborts "explode". 

- Faults: These can be corrected and the programmer may continue as if nothing happened. Eg. page fault 
- Traps: Traps are reported inmediately after the execution of the trapping instruction. Eg. int instruction
- Aborts: Some severe unrecoverable error. Eg. hardware failure

### General protection Fault

A general protection fault may occur for various reasons, the most common:

- segment error (privilege, type, limit, read/write rights).
- executing priviledged instructions while CPL (current privilege level) is not equal to 0.
- writing a 1 in a reserved register field.
- referencing or accessing a null-descriptor.
- trying to access an unimlemented register (like mov cr6, eax)
- the saved instruction pointer points to the instruction which causes the exception

#### Example 1
So for example for a divide by zero problem:

```c
  // divide_by_zero.c
  1 #include <stdio.h>                                                               
  2                                                                                  
  3 int main()                                                                       
  4 {                                                                                
  5 »       int i = 1/0;                                                             
  6 »       return 0;                                                                
  7 }                                                                                 
```

```bash
sergio@laptop:~/repos/divide-by-zero$ gcc -o div_by_zero.c divide_by_zero.c 
divide_by_zero.c: In function ‘main’:
divide_by_zero.c:5:18: warning: division by zero [-Wdiv-by-zero]
    5 |         int i = 1/0;
      |           
```
what should happen here?

```bash
sergio@laptop:~/repos/divide-by-zero$ ls
div_by_zero.c  divide_by_zero.c
sergio@laptop:~/repos/divide-by-zero$ sudo dmesg -WH &
[1] 6310
sergio@laptop:~/repos/divide-by-zero$ ./div_by_zero.c 
[oct 8 16:43] traps: div_by_zero.c[6315] trap divide error ip:55d9a6c7b13c sp:7ffc0f832c10 error:0 in div_by_zero.c[55d9a6c7b000+1000]
Floating point exception (core dumped)
```

#### Example 2

```c
  //  userapp.c 
  1 #include <stdio.h>                                                               
  2 #include </usr/include/sys/io.h>                                                 
  3                                                                                  
  4 int main()                                                                       
  5 {                                                                                
  6 »       outb(0x80, 0x00);                                                        
  7 »       return 0;                                                                
  8 }   
```

```
sergio@laptop:~/repos/divide-by-zero$ gcc -o userapp userapp.c peers lock
sergio@laptop:~/repos/divide-by-zero$ sudo dmesg -WH &
sergio@laptop:~/repos/divide-by-zero$ ./userapp
[oct 8 19:56] show_signal: 1 callbacks suppressed
[  +0,000006] traps: userapp[4589] general protection fault ip:55c13b8c4140 sp:7fff1bd28c70 error:0 in userapp[55c13b8c4000+1000]
Segmentation fault (core dumped)
```

In this case we are attemping to write to a memory that it is now allow, we don't have access writes, so a general protection fault is triggered.


We can see it should be a fault, but in linux is denominated as a trap. 

### How debuggers work?

To implement breakpoints on the x86 architecture, software interrupts (also known as "traps") are used.

Breakpoints are implemented on the CPU by a special trap called int 3.

`int` is 0x86 jargon for "trap instruction" - a call to a predefined interrupts handler. 

x86 supports the int instruction with a 8-bit operand specifying the number of the interrupt that occurred.

```c
  1 #include <stdio.h>                                                               
  2                                                                                  
  3 int main() {                                                                     
  4 »       int i = 0;                                                               
  5 »       while (i < 6) {                                                          
  6 »       »       printf("i equals to: %d\n", i);                                  
  7 »       »       ++i;                                                             
  8 »       }                                                                        
  9 »       __asm__("int3");                                                         
 10 }                                                                                            
```

```bash
sergio@laptop:~/repos/divide-by-zero$ gcc -o int3 interrupt.c 
sergio@laptop:sudo dmesg -WH &
i equals to: 0
i equals to: 1
i equals to: 2
i equals to: 3
i equals to: 4
i equals to: 5
[  +1,920005] traps: int3[7075] trap int3 ip:55f6a6900182 sp:7ffdc37606c0 error:0 in int3[55f6a6900000+1000]
Trace/breakpoint trap (core dumped)
```

but if we debug the program with gcc: 

```
sergio@laptop:~/repos/divide-by-zero$ gdb ./int3 
GNU gdb (Ubuntu 12.1-3ubuntu2) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./int3...

This GDB supports auto-downloading debuginfo from the following URLs:
https://debuginfod.ubuntu.com 
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
(No debugging symbols found in ./int3)
(gdb) run
Starting program: /home/sergio/repos/divide-by-zero/int3 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
i equals to: 0
i equals to: 1
i equals to: 2
i equals to: 3
i equals to: 4
i equals to: 5

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000555555555182 in main ()
(gdb) 
```
the program was ran, and stoped by itself at the int3 (breakpoint trap)

if we continue the program, it will exit normally:

```
Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000555555555182 in main ()
(gdb) c
Continuing.
[Inferior 1 (process 7187) exited normally]
```

### Hardware interrupt triggering methods

Each interrupt signal input is designed to be triggered by either a logical signal event or particular edge (level transition)

#### Level triggered 

Interrupt is requested by holding the interrupt signal at its particular (high or low) active logic level.
Level triggered interrupts happen as long as the interrupt line is held active level. 

As long as the line, you get interrupt, when you serve the interrupt and return, it the interrupt line is still 
active, you get the interrupt again inmediatelly. 

#### Edge triggered

Interrupt is requested by a level transition on the interrupt line. 
 - Falling edge (high to low)
 - Rising edge (Low to high)

These interrupts are issued per transition and not repeated. E.g. in networking when the packet queue goes from
empty to non-empty. This makes it critical to never miss an edge triggered interrupt, because failure to handle
one interrupt result in no further interrupts from happening. 

### Masking

Processors typically have an internal interrupt mask register. This allows selective enabling and disabling 
of hardware interrupts. 

Each interrupt signal is associated with a bit in the mask register
- Bit = 1, Interrupt enabled
- Bit = 0, Interrupt disabled

When the interrupt is disabled, the associated interrupt signal will be ignored by the processor. 

Maskable interrupts: Interrupts which can be enabled/disabled.

Non maskable interrupts: Interrupts which cannot be disabled. Example: NMI, timeout signal from watchdog timer. 

For example the 8086 processor has two hardware interrupt signals:

- NMI non-maskable interrupt
- INTR Interrupt request (maskable interrupt)

How to support more than two interrupts?

It would be very unproductive to make a ton of INTR pins on the CPU for all of them.

To solve this problem a special chip was invented, the interrupt controller. 

### Programable interrupt controller (PIC) 

The Intel 8259 Programmable Interrupt Controller (PIC) is one of the most important chips making the x86 architecture.

reference: https://en.wikipedia.org/wiki/Intel_8259

It allows multiplexing the single INT line on the x86 processor to multiple interrupts lines.
Interrupt lines can be assigned various hardware priority levels, as well as a programmable interrupt masking.

Each PIC has 8 interrupts lines called Interrupt ReQuests (IRQ), numbered from 0 to 7. 
PIC has one output line which connects the INTR line to the CPU. 

A device supporting interrupts has an output pin used for signalling an Interrupt ReQuest (IRQ)

CPU will know that some devices requires its inmediate attention, and the processor will ask the PIC which 
of the 8 input lines (IRQx) was the source of the interruption.

#### Why call Interrupt ReQuest (IRQ)

Peripheral devices cannot directly force interrupts, but has to request them via the PIC, we call them IRQ
or Interrupt ReQuests. 

#### Dual PIC

Soon 8 lines were not enough. To increase the total number of interrupt lines two 8259 PIC controllers
(master and slave) were connected in cascade (Dual PIC). 

- IRQs from 0 to 7 where processed with the first Intel 8259 PIC (master)
- IRQs from 8 to 15 are processed with the second Intel 8259 PIC (slave)

Only the master is connected to the CPU and can signal about the incomming interrupts.
It there is an interrupt on lines 8-15, the second PIC (slave) will signal about it to the master
on the line IRQ 2, and after that the master will signal the CPU. 

#### Port Interface

Two separate dedicated ports in the x86 IO-port space for each connected PIC

- Master PIC - 0x20, 0x21
- Slave  PIC - 0xA0, 0xA1

```
# sudo cat /proc/ioports | grep -i pic # you really need to use sudo!
```

#### Device interrupt mapping

Devices were initially statically assign, so the assignations were: 


##### Master PIC
- IRQ 0 — system timer
- IRQ 1 — keyboard controller
- IRQ 2 — cascade (interrupt from slave controller)
- IRQ 3 — serial port COM2
- IRQ 4 — serial port COM1
- IRQ 5 — parallel port 2 and 3 or sound card
- IRQ 6 — floppy controller
- IRQ 7 — parallel port 1

##### Slave PIC
- IRQ 8 — RTC timer
- IRQ 9 — ACPI
- IRQ 10 — open/SCSI/NIC
- IRQ 11 — open/SCSI/NIC
- IRQ 12 — mouse controller
- IRQ 13 — math co-processor
- IRQ 14 — ATA channel 1
- IRQ 15 — ATA channel 2



























