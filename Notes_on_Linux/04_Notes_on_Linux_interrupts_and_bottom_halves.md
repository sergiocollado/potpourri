# Notes on Linux interrupt and bottom halves


## Interrupts 

references:
- MUST READ LDD3: https://static.lwn.net/images/pdf/LDD3/ch10.pdf
- https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html
- https://sysprog21.github.io/lkmpg/#scheduling-tasks
- https://sysprog21.github.io/lkmpg/#interrupt-handlers
- https://en.wikipedia.org/wiki/Interrupt_vector_table
- https://en.wikipedia.org/wiki/Interrupt_handler
- https://tldp.org/HOWTO/Plug-and-Play-HOWTO-7.html
- https://people.freebsd.org/~jhb/papers/bsdcan/2007/article/article.html
- https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller
- https://elixir.bootlin.com/linux/v6.5.7/source/include/linux/interrupt.h
- https://elixir.bootlin.com/linux/v6.5.7/source/arch/x86/kernel/irq.c
- https://linux.die.net/HOWTO/KernelAnalysis-HOWTO.html#toc1
- https://docs.kernel.org/core-api/irq/index.html
- IRQs: the Hard, the Soft, the Threaded and the Preemptible : https://youtu.be/-pehAzaP1eg
- https://www.oreilly.com/library/view/understanding-the-linux/0596005652/ch04s06.html


### What is an interrupt?

- reference: https://docs.kernel.org/core-api/irq/concepts.html

An interrupt is an input signal to the processor, sent by the hardware peripherals when they need processor attention. 

An IRQ is an interrupt request from a device. Currently they can come in over a pin, or over a packet. Several devices may be connected to the same pin thus sharing an IRQ.

An IRQ number is a kernel identifier used to talk about a hardware interrupt source. Typically this is an index into the global irq_desc array, but except for what linux/interrupt.h implements the details are architecture specific.

An IRQ number is an enumeration of the possible interrupt sources on a machine. Typically what is enumerated is the number of input pins on all of the interrupt controller in the system. In the case of ISA what is enumerated are the 16 input pins on the two i8259 interrupt controllers.

Architectures can assign additional meaning to the IRQ numbers, and are encouraged to in the case where there is any manual configuration of the hardware involved. The ISA IRQs are a classic example of assigning this kind of additional meaning.


### What is the purpose of the interrupts?

For example, if we want to perform an action with an incomming packet from the network card as soon as the packet arrives.

If you don't want to continously ask the network card "has any packet arrive yet?" and waste processor time, you
can use external hardware interrupt IRQ

The interrupt line from a device should be connected to the INTR line of the CPU, and after each packet is received,
the network card will make a signal over this line. 

The CPU will sense this line and know that the network card has information for it.

Only after that, the CPU will read the incoming packet. 

### Types of interrupt

1. - Hardware / asynchronous:
     - Generated by hw devices
     - Occours at arbitrary times (asynchronous) with respect to the clock signals
     - Examples: processing of a key on the keyboard, mouse movement, timer fired, network card reporting arrival of a packet...
2. - Software / synchronous:
     - Generated by executing instructions
     - Occorus synchronously with respect to processor clock
     - Also called as exceptions/traps
     - Examples: divide-by-zero, system call, page fault
    
### Exceptions

Exceptions are classified as faults, traps, and abort, depending on the way they are reported and whether the instruction 
that caused the exception can be restared, without loss of programs. 

Traps increment the instruction pointer, faults don't, and aborts "explode". 

- Faults: These can be corrected and the programmer may continue as if nothing happened. Eg. page fault 
- Traps: Traps are reported inmediately after the execution of the trapping instruction. Eg. int instruction
- Aborts: Some severe unrecoverable error. Eg. hardware failure

### General protection Fault

A general protection fault may occur for various reasons, the most common:

- segment error (privilege, type, limit, read/write rights).
- executing priviledged instructions while CPL (current privilege level) is not equal to 0.
- writing a 1 in a reserved register field.
- referencing or accessing a null-descriptor.
- trying to access an unimlemented register (like mov cr6, eax)
- the saved instruction pointer points to the instruction which causes the exception

#### Example 1
So for example for a divide by zero problem:

```c
  // divide_by_zero.c
  1 #include <stdio.h>                                                               
  2                                                                                  
  3 int main()                                                                       
  4 {                                                                                
  5 »       int i = 1/0;                                                             
  6 »       return 0;                                                                
  7 }                                                                                 
```

```bash
sergio@laptop:~/repos/divide-by-zero$ gcc -o div_by_zero.c divide_by_zero.c 
divide_by_zero.c: In function ‘main’:
divide_by_zero.c:5:18: warning: division by zero [-Wdiv-by-zero]
    5 |         int i = 1/0;
      |           
```
what should happen here?

```bash
sergio@laptop:~/repos/divide-by-zero$ ls
div_by_zero.c  divide_by_zero.c
sergio@laptop:~/repos/divide-by-zero$ sudo dmesg -WH &
[1] 6310
sergio@laptop:~/repos/divide-by-zero$ ./div_by_zero.c 
[oct 8 16:43] traps: div_by_zero.c[6315] trap divide error ip:55d9a6c7b13c sp:7ffc0f832c10 error:0 in div_by_zero.c[55d9a6c7b000+1000]
Floating point exception (core dumped)
```

#### Example 2

```c
  //  userapp.c 
  1 #include <stdio.h>                                                               
  2 #include </usr/include/sys/io.h>                                                 
  3                                                                                  
  4 int main()                                                                       
  5 {                                                                                
  6 »       outb(0x80, 0x00);                                                        
  7 »       return 0;                                                                
  8 }   
```

```
sergio@laptop:~/repos/divide-by-zero$ gcc -o userapp userapp.c peers lock
sergio@laptop:~/repos/divide-by-zero$ sudo dmesg -WH &
sergio@laptop:~/repos/divide-by-zero$ ./userapp
[oct 8 19:56] show_signal: 1 callbacks suppressed
[  +0,000006] traps: userapp[4589] general protection fault ip:55c13b8c4140 sp:7fff1bd28c70 error:0 in userapp[55c13b8c4000+1000]
Segmentation fault (core dumped)
```

In this case we are attemping to write to a memory that it is now allow, we don't have access writes, so a general protection fault is triggered.


We can see it should be a fault, but in linux is denominated as a trap. 

### How debuggers work?

To implement breakpoints on the x86 architecture, software interrupts (also known as "traps") are used.

Breakpoints are implemented on the CPU by a special trap called int 3.

`int` is 0x86 jargon for "trap instruction" - a call to a predefined interrupts handler. 

x86 supports the int instruction with a 8-bit operand specifying the number of the interrupt that occurred.

```c
  1 #include <stdio.h>                                                               
  2                                                                                  
  3 int main() {                                                                     
  4 »       int i = 0;                                                               
  5 »       while (i < 6) {                                                          
  6 »       »       printf("i equals to: %d\n", i);                                  
  7 »       »       ++i;                                                             
  8 »       }                                                                        
  9 »       __asm__("int3");                                                         
 10 }                                                                                            
```

```bash
sergio@laptop:~/repos/divide-by-zero$ gcc -o int3 interrupt.c 
sergio@laptop:sudo dmesg -WH &
i equals to: 0
i equals to: 1
i equals to: 2
i equals to: 3
i equals to: 4
i equals to: 5
[  +1,920005] traps: int3[7075] trap int3 ip:55f6a6900182 sp:7ffdc37606c0 error:0 in int3[55f6a6900000+1000]
Trace/breakpoint trap (core dumped)
```

but if we debug the program with gcc: 

```
sergio@laptop:~/repos/divide-by-zero$ gdb ./int3 
GNU gdb (Ubuntu 12.1-3ubuntu2) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./int3...

This GDB supports auto-downloading debuginfo from the following URLs:
https://debuginfod.ubuntu.com 
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
(No debugging symbols found in ./int3)
(gdb) run
Starting program: /home/sergio/repos/divide-by-zero/int3 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
i equals to: 0
i equals to: 1
i equals to: 2
i equals to: 3
i equals to: 4
i equals to: 5

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000555555555182 in main ()
(gdb) 
```
the program was ran, and stoped by itself at the int3 (breakpoint trap)

if we continue the program, it will exit normally:

```
Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000555555555182 in main ()
(gdb) c
Continuing.
[Inferior 1 (process 7187) exited normally]
```

### Hardware interrupt triggering methods

Each interrupt signal input is designed to be triggered by either a logical signal event or particular edge (level transition)

#### Level triggered 

Interrupt is requested by holding the interrupt signal at its particular (high or low) active logic level.
Level triggered interrupts happen as long as the interrupt line is held active level. 

As long as the line, you get interrupt, when you serve the interrupt and return, it the interrupt line is still 
active, you get the interrupt again inmediatelly. 

#### Edge triggered

Interrupt is requested by a level transition on the interrupt line. 
 - Falling edge (high to low)
 - Rising edge (Low to high)

These interrupts are issued per transition and not repeated. E.g. in networking when the packet queue goes from
empty to non-empty. This makes it critical to never miss an edge triggered interrupt, because failure to handle
one interrupt result in no further interrupts from happening. 

### Masking

Processors typically have an internal interrupt mask register. This allows selective enabling and disabling 
of hardware interrupts. 

Each interrupt signal is associated with a bit in the mask register
- Bit = 1, Interrupt enabled
- Bit = 0, Interrupt disabled

When the interrupt is disabled, the associated interrupt signal will be ignored by the processor. 

Maskable interrupts: Interrupts which can be enabled/disabled.

Non maskable interrupts: Interrupts which cannot be disabled. Example: NMI, timeout signal from watchdog timer. 

For example the 8086 processor has two hardware interrupt signals:

- NMI non-maskable interrupt
- INTR Interrupt request (maskable interrupt)

How to support more than two interrupts?

It would be very unproductive to make a ton of INTR pins on the CPU for all of them.

To solve this problem a special chip was invented, the interrupt controller. 

### Programable interrupt controller (PIC) 

The Intel 8259 Programmable Interrupt Controller (PIC) is one of the most important chips making the x86 architecture.

reference: https://en.wikipedia.org/wiki/Intel_8259

It allows multiplexing the single INT line on the x86 processor to multiple interrupts lines.
Interrupt lines can be assigned various hardware priority levels, as well as a programmable interrupt masking.

Each PIC has 8 interrupts lines called Interrupt ReQuests (IRQ), numbered from 0 to 7. 
PIC has one output line which connects the INTR line to the CPU. 

A device supporting interrupts has an output pin used for signalling an Interrupt ReQuest (IRQ)

CPU will know that some devices requires its inmediate attention, and the processor will ask the PIC which 
of the 8 input lines (IRQx) was the source of the interruption.

#### Why call Interrupt ReQuest (IRQ)

Peripheral devices cannot directly force interrupts, but has to request them via the PIC, we call them IRQ
or Interrupt ReQuests. 

#### Dual PIC

Soon 8 lines were not enough. To increase the total number of interrupt lines two 8259 PIC controllers
(master and slave) were connected in cascade (Dual PIC). 

- IRQs from 0 to 7 where processed with the first Intel 8259 PIC (master)
- IRQs from 8 to 15 are processed with the second Intel 8259 PIC (slave)

Only the master is connected to the CPU and can signal about the incomming interrupts.
It there is an interrupt on lines 8-15, the second PIC (slave) will signal about it to the master
on the line IRQ 2, and after that the master will signal the CPU. 

#### Port Interface

Two separate dedicated ports in the x86 IO-port space for each connected PIC

- Master PIC - 0x20, 0x21
- Slave  PIC - 0xA0, 0xA1

```
# sudo cat /proc/ioports | grep -i pic # you really need to use sudo!
```

#### Device interrupt mapping

Devices were initially statically assign, so the assignations were: 


##### Master PIC
- IRQ 0 — system timer
- IRQ 1 — keyboard controller
- IRQ 2 — cascade (interrupt from slave controller)
- IRQ 3 — serial port COM2
- IRQ 4 — serial port COM1
- IRQ 5 — parallel port 2 and 3 or sound card
- IRQ 6 — floppy controller
- IRQ 7 — parallel port 1

##### Slave PIC
- IRQ 8 — RTC timer
- IRQ 9 — ACPI
- IRQ 10 — open/SCSI/NIC
- IRQ 11 — open/SCSI/NIC
- IRQ 12 — mouse controller
- IRQ 13 — math co-processor
- IRQ 14 — ATA channel 1
- IRQ 15 — ATA channel 2

#### Programmable Interrupt Request (PIRQ)

Initially, the x86 used ISA Bus (https://en.wikipedia.org/wiki/Industry_Standard_Architecture).

The PCI bus, later replaced the ISA bus. Unfortunately the number of devices began to exceed the number 15. 
Also instead of the static ISA bus, devices in the PCI bus can be added to the system dynamically. 
Interrupts in the PCI bus can be shared, so it is possible to connect many devices to one interrupt line IRQ. 

In the end, to solve the problem of lack of interrupt lines, it was decided to group interrupts from all 
the PC devices to PIRQ lines (Progammable Interrupt ReQuests). 

For example, suppouse we have 4 free interrupts lines on the PIC controller and 20 PCI devices. 
We can combine interrupts from 5 devices into one PIRQx line, and connect those PIRQx lines to the PIC controller.
In this case if there is an interrupt on the PIRQx lines, the processor will have to ask all the devices 
connected to this line about the interrupt to know who is responsible for it, but in the end it solves 
the problem. 

The device that connects the PCI interrupt lines to PIRQ lines is often called a PIR router. 
This method ensures that PIRQx interrupt lines don't connect to lines with ISA interrupts (since 
this will produce conflicts). System software, such as the BIOS or operating system, is
responsible for programming the interrupt router. 

- reference: https://tldp.org/HOWTO/Plug-and-Play-HOWTO-7.html
- reference: https://people.freebsd.org/~jhb/papers/bsdcan/2007/article/article.html

#### APIC (Advanced PIC)

The PIC method only works for a single processor systems.

PIC can only send interrupts to one CPU, and in a multiprocessor system it is desired to load CPUs in a balanced way.

The solution to this problem was the new APIC interface (Advanced PIC).

It is comprised of two components: 
 - IO-APIC - Interfaces with Devices.
 - LAPIC - the local APIC - Interfaces with CPU.

reference: https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller

##### LAPIC 

Each processor in a multiprocessor system consists on a LAPIC (local APIC). Responsible for: 
- receiving various interrupts requests and delivering them to the processor.
- handling prioritization of interrupts
- sending interrupts to other processors (known as inter processor interrutps or IPIs)

LAPIC can be connected directly to I/O devices via local interrupt inputs (timer, thermal sensor) or
throught IOAPIC via external interrupts. 

LAPIC can generate interrupts due to interrupt requests received from various sources: 
 - IPIs received from other processors.
 - Interrupts coming from LINT or EXTINT

##### I/O PIC

Connects to the devices to allow device interrupt requests to be routed to LAPIC(s).
There can be one or more IOAPIC in the system. Each IOAPIC has 24 interruption lines. 
IOAPIC receives interrupts requests from the devices and sends them to LAPIC(s) based
upon the redirection table entries (RTE) programmed in the IOAPIC. 

Note: to maintain backward compatibility, APIC emulates 8259 PIC. 

###### Detection

The CPUID.01h:EDX[bit 9] flag specifies whether a CPU has a build-in local APIC. 


#### CPUID

CPUID is an x86 opcode which stands for CPU Identification.

The CPUID instruction can be used to retrieve various amount of information about your cpu: 
 - vendor string
 - model number
 - size of the internal caches
 - list of CPU features

```
man 4 cpuid
```

The cpuid driver is not auto-loaded. On modular kernels you might need to use the following 
command to load it explicitly before use: 

```
modprobe cpuid
```

Most of the information in cpuid is reported by the kernel in cooked form either in /proc/cpuinfo

```
cat /proc/cpuinfo | grep - i apicid
```
apicid: An unique ID given to each logical processor upon startup. 

We can check on the system log, the "apic" messages: 

```
sudo dmesg | grep -i apic
```

### What happens when there is an interrupt?

The device asserts IRQ of I/O APIC. 

I/O APIC transfer interrupt to LAPIC. 

LAPIC asserts CPU interrupts.

After current instrucction completes CPU senses interrupt line and obtains the IRQ number from LAPIC, jumps to the interrupt handler. 


### How does the hardware find the interrupt handler? 

#### Interrupt vector (IV)

On x86 each interrupt or exception is identified by a number between 0 and 255. Intel calls this number a vector. 

The interrupt vector is used by the interrupt-handling mechanisms to locate the system-software service routine
assigned to the exception or interrupt.

Up to 256 unique interrupt vectors are available in x86.

The number or interrupt vectors or entry points supported by a CPU differs based on the CPU architecture. 

The first 32 vector entries are reserved for predefined exceptions and interrupt conditions. 

Look into arch/x86/include/asm/traps.h. For example: https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/trapnr.h

```
// https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/trapnr.h
/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _ASM_X86_TRAPNR_H
#define _ASM_X86_TRAPNR_H

/* Interrupts/Exceptions */

#define X86_TRAP_DE		 0	/* Divide-by-zero */
#define X86_TRAP_DB		 1	/* Debug */
#define X86_TRAP_NMI	         2	/* Non-maskable Interrupt */
#define X86_TRAP_BP		 3	/* Breakpoint */
#define X86_TRAP_OF		 4	/* Overflow */
#define X86_TRAP_BR		 5	/* Bound Range Exceeded */
#define X86_TRAP_UD		 6	/* Invalid Opcode */
#define X86_TRAP_NM		 7	/* Device Not Available */
#define X86_TRAP_DF		 8	/* Double Fault */
#define X86_TRAP_OLD_MF	         9	/* Coprocessor Segment Overrun */
#define X86_TRAP_TS		10	/* Invalid TSS */
#define X86_TRAP_NP		11	/* Segment Not Present */
#define X86_TRAP_SS		12	/* Stack Segment Fault */
#define X86_TRAP_GP		13	/* General Protection Fault */
#define X86_TRAP_PF		14	/* Page Fault */
#define X86_TRAP_SPURIOUS	15	/* Spurious Interrupt */
#define X86_TRAP_MF		16	/* x87 Floating-Point Exception */
#define X86_TRAP_AC		17	/* Alignment Check */
#define X86_TRAP_MC		18	/* Machine Check */
#define X86_TRAP_XF		19	/* SIMD Floating-Point Exception */
#define X86_TRAP_VE		20	/* Virtualization Exception */
#define X86_TRAP_CP		21	/* Control Protection Exception */
#define X86_TRAP_VC		29	/* VMM Communication Exception */
#define X86_TRAP_IRET	        32	/* IRET Exception */
#endif
```

#### Interrupt descriptor table (IDT)

The IDT (Interrupt Descriptor Table) is a linear table of 258 entries which associates an interrupt handler with each interrupt vector. 

When an interrupt is fired, the CPU looks at the IDT table, and finds what method needs to be called. 

Each descriptor is of size 8 bytes (on x86) and 16 bytes (on x86_64)

During early boot, the architecure-specific branch of the kernel code sets up the IDT in memory and programs
the IDTR register (special 0x86 register) of the processor with the physical start address and length of the IDT. 


## Interrupt handling in Linux Kernel

- reference: https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html#interrupt-handling-in-linux

1. Whenever an interrupt occurs, assembly instructions in linux kernel are executed, which
locates relevant vector descriptor by multiplying reported vector number by size of vector number(8/16)
and adding the result to the base address of IDT.

2. common_interrupt: [arch/x86/entry/entry_64.S](https://elixir.bootlin.com/linux/v6.5.7/source/arch/x86/entry/entry_64.S):
	- saves the context of the running process
	- This includes instruction pointer (IP), stack pointer and other registers needed to resume the process again
	- This context is usually saved on the stack.
	- Then the context is changed to interrupt stack.

reference: https://elixir.bootlin.com/linux/v6.5.7/source/arch/x86/entry/entry_64.S

2. Finally it arrives at `do_IRQ()`. `do_IRQ()` is the common function for all hardware interrupts

```
	arch/x86/kernel/irq.c
```
 - reference: https://elixir.bootlin.com/linux/v6.5.7/source/arch/x86/kernel/irq.c

3. Finds IRQ number in saved %EAX register

4. Calls handle_irq which will finally call our registered interrupt handler.

### Interrupt statistics

To check the interrupt statistics: 

```
$ cat /proc/interrupts
```
or to see how those change dinamically:

```
$ watch -d -n 1 cat /proc/interrupts | less
```

 - reference: https://linux.die.net/man/5/proc

```
# cat /proc/interrupts
```
This is used to record the number of interrupts per CPU per IO device. Since Linux 2.6.24, for the i386 and x86_64 architectures, at least, this also includes interrupts internal to the system (that is, not associated with a device as such), such as NMI (nonmaskable interrupt), LOC (local timer interrupt), and for SMP systems, TLB (TLB flush interrupt), RES (rescheduling interrupt), CAL (remote function call interrupt), and possibly others. Very easy to read formatting, done in ASCII.

```
$ cat /proc/interrupts

           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       
   0:          2          0          0          0          0          0   IO-APIC    2-edge      timer
   1:        458          0          0          0       6154          0   IO-APIC    1-edge      i8042
   8:          0          0          0          0          0          1   IO-APIC    8-edge      rtc0
   9:          0          0          0          0          0          0   IO-APIC    9-fasteoi   acpi
  12:          0          0          0      22185          0          0   IO-APIC   12-edge      i8042
  14:          0          0          0          0          0          0   IO-APIC   14-edge      ata_piix
  15:          0          0          0          0          0          0   IO-APIC   15-edge      ata_piix
  16:          0      19541          0          0          0          0   IO-APIC   16-fasteoi   vmwgfx, snd_ens1371
  17:       9825          0      47519          0          0          0   IO-APIC   17-fasteoi   ehci_hcd:usb1, i
```

 - Column 1:  IRQ number the file shows only interrupts corresponding to installed handlers

 - Column 2:  counter of the number of interrupts received. A column is present for each processor on the system

 - Column 3/4: Type of the interrupt and device that handles the interrupt.
           -  For x86.
           -  XT-PIC — This is the old AT computer interrupts. 8259
           -  IO-APIC 

 - Column 5:  device associated with this interrupt. This name is supplied by the devname parameter to request_irq(),
            


#### Difference between  IO-APIC-fasteoi and IO-APIC-edge?

The difference lies in the way the interrupts are triggered.

The `-edge` interrupt are edge triggered.

The `-fasteoi` interrupts are level interrupts that are triggered until the interrupt event is acknowledged in the programmable interrupt controller (PIC). 

The EOI stands for End Of Interrupt.

### Watch Interrupts

To see the interrupts occurring on your system, run the command:

```
$ watch -n1 "cat /proc/interrupts"
```

The watch command executes another command periodically, in this case `cat /proc/interrupts`

The `-n1` option tells watch to execute the command every second

`-d` option of watch highlight  the  differences  between successive updates

```
$ watch -n 0.1 -d 'cat /proc/interrupts'
```

`--no-title / -t` option of watch Turn off the header showing the interval, command, and current time at the top of the display, as well as the following blank line.

```
$ watch -n 0.1 -d --no-title 'cat /proc/interrupts'
```

### PCI interrutps 

`lspci` is a utility for displaying information about PCI buses in the system and devices connected to them.

By default, it shows a brief list of devices. Use the options described below to request 
either a more verbose output or output intended for parsing by other programs.

reference: https://man7.org/linux/man-pages/man8/lspci.8.html

```
$ lspci | grep -i Ethernet

$ lspci -s 02:01 -v
```

### Interrupt handlers


Interrupt handlers are the responsibility of the driver managing the hardware.

If the device uses interrupts, then driver must register one interrupt handler.

#### Registering an interrupt handler

Header File: <linux/interrupt.h>

```
int request_irq(unsigned int irq,
        irq_handler_t handler,
        unsigned long flags,
        const char *name,
        void *dev);
```

#### Parameters:

```
irq     --> The interrupt number being requested
            For some devices,for example legacy PC devices such as the system timer or keyboard, this value is typically hard-coded.
            For most other devices, it is probed or otherwise determined programmatically and dynamically.

handler   --> function pointer to the actual interrupt handler that services this interrupt.
              invoked whenever the operating system receives the interrupt
              typedef irqreturn_t (*irq_handler_t)(int, void *);

flags     --> bitmask of options related to interrupt management.

name      --> Name to be displayed in /proc/interrupts

dev       --> Used for shared Interrupt Lines
```

#### Return Value:

Success  -->    Returns Zero
Failure  -->    Non-Zero Value

```               
void free_irq(unsigned int irq_no, void *dev);
```

When the interrupt is released, using the `free_irq()` function, you must send the same pointer value (dev) along with the same interrupt number (irq_no).

### Example: keyboard interrupt

- reference: https://stackoverflow.com/questions/33836541/linux-kernel-how-to-capture-a-key-press-and-replace-it-with-another-key
- reference: https://unix.stackexchange.com/questions/545274/how-does-a-keyboard-press-get-processed-in-the-linux-kernel
- reference: https://elixir.bootlin.com/linux/v6.5.7/source/drivers/tty/vt/keyboard.c
- reference: https://elixir.bootlin.com/linux/v6.5.7/source/drivers/tty/vt/defkeymap.map
- reference: https://unix.stackexchange.com/questions/424273/capturing-keypresses-at-kernel-level
- reference: https://github.com/MemoryDealer/linux-keylogger
- reference: https://github.com/jarun/spy/blob/master/spy.c

When a key is pressed, the keyboard controller informs PIC to cause an interrupt.

IRQ #1 is the keyboard interrupt, so when a key is pressed, IRQ 1 is sent to the PIC. 

PIC tells the CPU an interrupt occurred.

When the CPU acknowledges the "interrupt occurred" signal, the PIC chip sends the interrupt number (between 00h and FFh, or 0 and 255 decimal) to the CPU.

For each key pressed on the keyboard, it generates two interrupts (pressed and release).

```
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");

static int irq = 1,  dev = 0xaa, counter = 0;

static irqreturn_t keyboard_handler(int irq, void *dev)
{
        pr_info("Keyboard Counter:%d\n", counter++);
        return IRQ_NONE;
}

/* registering irq */
static int test_interrupt_init(void)
{
        pr_info("%s: In init\n", __func__);
        return request_irq(irq, keyboard_handler, IRQF_SHARED,"my_keyboard_handler", &dev);
}

static void test_interrupt_exit(void)
{
        pr_info("%s: In exit\n", __func__);
        synchronize_irq(irq); /* synchronize interrupt */
        free_irq(irq, &dev);
}

module_init(test_interrupt_init);
module_exit(test_interrupt_exit);
```
You can check the interrupt handler has been installed properly with  `cat /proc/interrupt`, and at IRQ 1 you should see the name "my_keyboard_handler". 

A keyboard generates two scan codes for each key typed on the system, one scan code for press and the other for release.

Release scan code is 128 (80h) plus the press scan code

```
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/interrupt.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");

const unsigned char kbdus[128] =    /* these are the scan codes */
{
  0,  27, '1', '2', '3', '4', '5', '6', '7', '8',	/* 9 */
  '9', '0', '-', '=', '\b',	/* Backspace */
  '\t',			/* Tab */
  'q', 'w', 'e', 'r',	/* 19 */
  't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n',	/* Enter key */
    0,			/* 29   - Control */
  'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',	/* 39 */
 '\'', '`',   0,		/* Left shift */
 '\\', 'z', 'x', 'c', 'v', 'b', 'n',			/* 49 */
  'm', ',', '.', '/',   0,				/* Right shift */
  '*',
    0,	/* Alt */
  ' ',	/* Space bar */
    0,	/* Caps lock */
    0,	/* 59 - F1 key ... > */
    0,   0,   0,   0,   0,   0,   0,   0,
    0,	/* < ... F10 */
    0,	/* 69 - Num lock*/
    0,	/* Scroll Lock */
    0,	/* Home key */
    0,	/* Up Arrow */
    0,	/* Page Up */
  '-',
    0,	/* Left Arrow */
    0,
    0,	/* Right Arrow */
  '+',
    0,	/* 79 - End key*/
    0,	/* Down Arrow */
    0,	/* Page Down */
    0,	/* Insert Key */
    0,	/* Delete Key */
    0,   0,   0,
    0,	/* F11 Key */
    0,	/* F12 Key */
    0,	/* All other keys are undefined */
};


static int irq = 1,  dev = 0xaa; /* IRQ 1: number for keyboard (i8042) */

#define KBD_DATA_REG        0x60    /* I/O port for keyboard data */
#define KBD_SCANCODE_MASK   0x7f
#define KBD_STATUS_MASK     0x80

static irqreturn_t keyboard_handler(int irq, void *dev)
{
	char scancode;
	scancode = inb(KBD_DATA_REG);
        /* refererence inb: https://linux.die.net/man/2/inb */
        /* This module is not cross-platform (will work only on x86 architecture, because it's using inb() function) */
        /* #define KBD_DATA_REG	0x60  Keyboard data register (R/W)  */
        /* https://elixir.bootlin.com/linux/v6.5.7/source/kernel/debug/kdb/kdb_keyboard.c#L21 */

	pr_info("Character %c %s\n",
			kbdus[scancode & KBD_SCANCODE_MASK],
			scancode & KBD_STATUS_MASK ? "Released" : "Pressed");
        /* It's performing slow I/O operation (I mean pr_info()) in hardware IRQ handler,
           which should be avoided (ideally threaded IRQs should be used)).*/

        return IRQ_NONE;
}

/* registering irq */
static int test_interrupt_init(void)
{
        pr_info("%s: In init\n", __func__);
        return request_irq(irq, keyboard_handler, IRQF_SHARED,"my_keyboard_handler", &dev);
}

static void test_interrupt_exit(void)
{
        pr_info("%s: In exit\n", __func__);
        synchronize_irq(irq); /* synchronize interrupt */
        free_irq(irq, &dev);
}

module_init(test_interrupt_init);
module_exit(test_interrupt_exit);
```

### Example: ethernet interrupt

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>

#define SHARED_IRQ 19
static int irq = SHARED_IRQ, my_dev_id, irq_counter = 0;
module_param(irq, int, S_IRUGO);

static irqreturn_t my_interrupt(int irq, void *dev_id)
{
	irq_counter++;
	pr_info("In the ISR: counter = %d\n", irq_counter);
	return IRQ_NONE;	/* we return IRQ_NONE because we are just observing */
}

static int __init my_init(void)
{
	if (request_irq
	    (irq, my_interrupt, IRQF_SHARED, "my_interrupt", &my_dev_id)) {
		pr_info("Failed to reserve irq %d\n", irq);
		return -1;
	}
	pr_info("Successfully loading ISR handler\n");
	return 0;
}

static void __exit my_exit(void)
{
	synchronize_irq(irq);
	free_irq(irq, &my_dev_id);
	pr_info("Successfully unloading,  irq_counter = %d\n", irq_counter);
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

### Example: mouse interrupt

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>

#define SHARED_IRQ 12
static int irq = SHARED_IRQ, my_dev_id, irq_counter = 0;
module_param(irq, int, S_IRUGO);

static irqreturn_t my_interrupt(int irq, void *dev_id)
{
	irq_counter++;
	pr_info("In the ISR: counter = %d\n", irq_counter);
	return IRQ_NONE;	/* we return IRQ_NONE because we are just observing */
}

static int __init my_init(void)
{
	if (request_irq
	    (irq, my_interrupt, IRQF_SHARED, "my_interrupt", &my_dev_id)) {
		pr_info("Failed to reserve irq %d\n", irq);
		return -1;
	}
	pr_info("Successfully loading ISR handler\n");
	return 0;
}

static void __exit my_exit(void)
{
	synchronize_irq(irq);
	free_irq(irq, &my_dev_id);
	pr_info("Successfully unloading,  irq_counter = %d\n", irq_counter);
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

## request_irq

It is defined at: https://elixir.bootlin.com/linux/v6.5.7/source/include/linux/interrupt.h#L165

```
/**
 * request_irq - Add a handler for an interrupt line
 * @irq:	The interrupt line to allocate
 * @handler:	Function to be called when the IRQ occurs.
 *		Primary handler for threaded interrupts
 *		If NULL, the default primary handler is installed
 * @flags:	Handling flags
 * @name:	Name of the device generating this interrupt
 * @dev:	A cookie passed to the handler function
 *
 * This call allocates an interrupt and establishes a handler; see
 * the documentation for request_threaded_irq() for details.
 */
static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
}
```

`void *dev` can be used to share or pass data with the interrupt handle. 

### Return value of interrupt handlers

Interrupt handlers return an `irqreturn_t` value.

 - `IRQ_NONE`            interrupt was not from this device or was not handled
 - `IRQ_HANDLED`         interrupt was handled by this device

### Interrupt flags

The third parameter of `request_irq`, `flags can be either a zero or a bit mask 
of one or more flags defined in <linux/interrupt.>

- reference: https://elixir.bootlin.com/linux/v6.5.8/source/include/linux/interrupt.h#L40

```
/*
 * These flags used only by the kernel as part of the
 * irq handling routines.
 *
 * IRQF_SHARED - allow sharing the irq among several devices
 * IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur
 * IRQF_TIMER - Flag to mark this interrupt as timer interrupt
 * IRQF_PERCPU - Interrupt is per cpu
 * IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing
 * IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is
 *                registered first in a shared interrupt is considered for
 *                performance reasons)
 * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.
 *                Used by threaded interrupts which need to keep the
 *                irq line disabled until the threaded handler has been run.
 * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend.  Does not guarantee
 *                   that this interrupt will wake the system from a suspended
 *                   state.  See Documentation/power/suspend-and-interrupts.rst
 * IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set
 * IRQF_NO_THREAD - Interrupt cannot be threaded
 * IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device
 *                resume time.
 * IRQF_COND_SUSPEND - If the IRQ is shared with a NO_SUSPEND user, execute this
 *                interrupt handler after suspending interrupts. For system
 *                wakeup devices users need to implement wakeup detection in
 *                their interrupt handlers.
 * IRQF_NO_AUTOEN - Don't enable IRQ or NMI automatically when users request it.
 *                Users will enable it explicitly by enable_irq() or enable_nmi()
 *                later.
 * IRQF_NO_DEBUG - Exclude from runnaway detection for IPI and similar handlers,
 *		   depends on IRQF_PERCPU.
 */
#define IRQF_SHARED		0x00000080
#define IRQF_PROBE_SHARED	0x00000100
#define __IRQF_TIMER		0x00000200
#define IRQF_PERCPU		0x00000400
#define IRQF_NOBALANCING	0x00000800
#define IRQF_IRQPOLL		0x00001000
#define IRQF_ONESHOT		0x00002000
#define IRQF_NO_SUSPEND		0x00004000
#define IRQF_FORCE_RESUME	0x00008000
#define IRQF_NO_THREAD		0x00010000
#define IRQF_EARLY_RESUME	0x00020000
#define IRQF_COND_SUSPEND	0x00040000
#define IRQF_NO_AUTOEN		0x00080000
#define IRQF_NO_DEBUG		0x00100000
```

 - `IRQF_SHARED` informs the kernel that the interrupt can be shared with other devices.

If this flag is not set, then if there is already a handler associated with the requested interrupt, 
the request for interrupt will fail. 

`request_irq` return `-EBUSY` which means that the interrupt was already requested by another device driver withou `IRQF_SHARED`. 

On success it returns 0. 

 - `IRQF_NOBALANCING` Flag to exclude this interrupt from irq balancing. The purpouse of IRQ balancing is to distribute hardware interrupts across processors on a
   multiprocessor system in order to increase performance. Setting this flag forbids to set any CPU affinity for the requested interrupt handler. 

### Example of a module that checks all the interrupts that are not being shared

```
#include <linux/interrupt.h>
#include <linux/kernel.h>
#include <linux/module.h>

#define MAX_IRQS 256

static int irqs[MAX_IRQS];
int dev = 1;

static irqreturn_t handler(int irq, void *dev)
{
	//pr_info("irq:%d\n", irq); /*commented because this will be bothersome if a interrupt is continuosly being triggered */
	return IRQ_NONE;            /* we return IRQ_NONE because we are just observing */
}

static int myinit(void)
{
	int ret, i;irqreturn_t

	for (i = 0; i < MAX_IRQS; ++i) {
		ret = request_irq(
			i,
			handler,
			IRQF_SHARED,
			"myirqhandler0",
			&dev
		);
		irqs[i] = ret;
		if (ret == -EBUSY)
			pr_err("request_irq failed irq = %d ret = %d\n", i, ret);
	}
	return 0;
}

static void myexit(void)
{
	int i;

	for (i = 0; i < MAX_IRQS; ++i) {
		if (!irqs[i]) {
			free_irq(i, &dev);
		}
	}
}

module_init(myinit)
module_exit(myexit)
MODULE_LICENSE("GPL");
```

### SMP IRQ affinity & /proc/irq

reference: https://docs.kernel.org/core-api/irq/irq-affinity.html

Starting with the 2.4 kernel, Linux has gained the ability to assign certain IRQs to specific processors (or groups of processors). This is known as **SMP IRQ affinity**.

The interrupt affinity value for a particular IRQ number is stored in the associated `/proc/irq/IRQ_NUMBER/smp_affinity` file, which can be viewed and modified by the root user. 

The value stored in this file is a hexadecimal bit-mask representing all CPU cores in the system
`/proc/irq/irq_number/smp_affinity_list` contains cpu list

Example: 

```
$ cat /proc/irq/1/smp_affinity

00000000,00000000,00000000,00000038
```
like: 
```
0x38 = 0011 1000 . couting from the left, zero indexed, that points to CPUs 3, 4 and 5. 
```

This mean keyboard interrupt can occur in CPU 3, 4, 5


Setting this value to 1, as follows, means that only CPU 0 can service this interrupt:

```
# echo 1 >/proc/irq/1/smp_affinity # 1 will point to cpu zero: 0001 
# cat /proc/irq/1/smp_affinity
1 
```

Commas can be used to delimit smp_affinity values for discrete 32-bit groups. This is required on systems with more than 32 cores. 

`/proc/irq/default_smp_affinity` specifies default affinity mask that applies to all non-active IRQs.

Once IRQ is allocated/activated its affinity bitmask will be set to the default mask. 


### How can a device driver know if the interrupt handler was activated by an interrupt generated by the device it manages?

All devices that offer interrupt support have a status register that can be read in the handling routine to see if the interrupt was or was not generated by the device 

Example:  For 8250 serial port, this status register is IIR - Interrupt Information Register

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/sched.h>
#include <asm/current.h>

static int irq1 = 12, dev_id;
static int irq2 = 1;

static irqreturn_t my_interrupt(int irq, void *dev_id)
{
	pr_info("irq:%d\t dev_id:%02x\n", irq, *(int *)dev_id);
	return IRQ_NONE;	/* we return IRQ_NONE because we are just observing */
}

static int __init my_init(void)
{
	dev_id = 0x1234;
	if (request_irq
	    (irq1, my_interrupt, IRQF_SHARED, "my_interrupt", &dev_id)) {
		pr_info("Failed to reserve irq %d\n", irq1);
		return -1;
	}
	if (request_irq
	    (irq2, my_interrupt, IRQF_SHARED, "my_interrupt", &dev_id)) {
		pr_info("Failed to reserve irq %d\n", irq1);
		return -1;
	}
	pr_info("Successfully loading ISR handler\n");
	return 0;
}

static void __exit my_exit(void)
{
	synchronize_irq(irq1);
	synchronize_irq(irq2);
	free_irq(irq1, &dev_id);
	free_irq(irq2, &dev_id);
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

## Enabling or disabling interrupts

The kernel has an API for enabling and disabling interrupts: 

Header file: <linux/irqflags.h> 

```
local_irq_disable(); // disable all interrupts on the current processor
local_irq_enable();  // enable all interrupts on the current processor
```

On x86 the `local_irq_disable()` is a simple `cli` and `local_irq_enable()` is a simple `sti` instrucctions. 

`cli` and `sti` are assembly calls to clear and set interrupt's flags.

### Why do we need to disable interrupts?

Disabling interrupts, you can guarantee that an **interrupt handler will not preempt your current code**.

Disabling interrupts also **disables kernel preemption**.

**Note**: Disabling kernel preemption does not provide protection from concurrent access from another processor.
In this case use **locks** to prevent another processor from accessing shared data simultaneously.

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/irqflags.h>

static int __init my_init(void)
{
	pr_info("module is loaded on processor:%d\n", smp_processor_id());
	local_irq_disable();
	pr_info("interrupts disabled on processor:%d\n", smp_processor_id());
	mdelay(10000L);
	local_irq_enable();
	return 0;
}

static void __exit my_exit(void)
{
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

### Saving interrupt state before disabling interrupts

`local_irq_disable()` routine is dangerous if some of interrupts were already disabled prior to its invocation.

The corresponding call to `local_irq_enable()` unconditionally enables interrupts, despite the fact that they were off to begin with.

`local_irq_save(flags)`; saves the interrupt state on flags and disables interrupt on that processor.

`local_irq_restore(flags)`; restores the previous interrupt state and enables interrupt on that processor. 

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/irqflags.h>

static int __init my_init(void)
{
	unsigned long flags;
	pr_info("module is loaded on processor:%d\n", smp_processor_id());
	local_irq_save(flags);
	pr_info("flags:%02lx\n", flags);
	mdelay(1000L);
	local_irq_restore(flags);
	return 0;
}

static void __exit my_exit(void)
{
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

### Disabling a specific interrupt line

Disabling a specific interrupt line is also known as "masking out an interrupt line" .

Example: you might want to disable delivery of a device’s interrupts before manipulating its state.

```
void disable_irq(unsigned int irq); // Disables a given interrupt line in interrupt controller.
			            // this disables delivery of the given interrupt to all processors in system

void enable_irq(unsigned int irq);
```

Note: `disable_irq` does not return until any executing handler completes. <br>
	Callers are ensured that:
		a) new interrupts will not be delivered on the given line,
		b) any already executing handlers have exited

### disable_irq_nosync

`void disable_irq_nosync(unsigned int irq);`

The function `disable_irq_nosync()` does not wait for current handlers to complete.

`void synchronize_irq(unsigned int irq);`

The function `synchronize_irq()` waits for a specific interrupt handler to exit, if it is executing, before returning.

`synchronize_irq()` spins until no interrupt handler is running for the given IRQ.

### What happens if i call disable_irq twice and enable_irq once?

Calls to these functions nest.

For each call to `disable_irq()` or `disable_irq_nosync()` on a given interrupt line, a corresponding call to enable_irq() is required. 

Only on the last call to `enable_irq()` is the interrupt line actually enabled.

For example, if `disable_irq()` is called twice, the interrupt line is not actually reenabled until the second call to `enable_irq()`.


### What happens if I disable interrupt line shared among multiple interrupt handlers?

Disabling the line disables interrupt delivery for all devices on the line.

Therefore, drivers for newer devices tend not to use these interfaces.

Because PCI devices have to support interrupt line sharing by specification, they should not use these interfaces at all.

Thus, `disable_irq()` and friends are found more often in drivers for older legacy devices, such as the PC parallel port.


### irqs_disabled()

The macro `irqs_disabled()`, returns nonzero if the interrupt system on the local processor is disabled.

Header File: <linux/irqflags.h>

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/irqflags.h>

void is_irq_disabled(void)
{
	if (irqs_disabled())
		pr_info("IRQ Disabled\n");
	else
		pr_info("IRQ Enabled\n");
}

static int __init my_init(void)
{
	pr_info("module is loaded on processor:%d\n", smp_processor_id());
	local_irq_disable();
	is_irq_disabled();
	mdelay(10000L);;
	local_irq_enable();
	is_irq_disabled();
	return 0;
}

static void __exit my_exit(void)
{
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

### Interrupt Context

When executing a interrupt handler, the kernel is in interrupt context

We know process context is the mode of operation the kernel is in while it is executing on behalf of a process.

Eg. Executing a system call.

As interrupt context is not backed with process, you cannot sleep in interrupt context.

If a function sleeps, you cannot use it from your interrupt handler 

Examples: kmalloc with GFP_KERNEL, ssleep.

reference: https://stackoverflow.com/questions/57987140/difference-between-interrupt-context-and-process-context

### Process Context
One of the most important parts of a process are the executing program code. This code was read in from a executable file and executed within the program's address space. Normal program execution occurs in User-space. When a program executes a system call or triggers an exception, it enters Kernel-space. At this point, the kernel are said to being "executing on behalf of the process" and are in process context. When in process context, the current macro is valid. Upon exiting the kernel, the process resumes execution in User-space, unless a higher-priority process have become runnable In the interim (transition period), in which case the scheduler is invoked to select the higher priority process.

### Interrupt Context
When executing a interrupt handler or bottom half, the kernel is in interrupt context.Recall That process context is the mode of operation the kernel are in while it's executing on behalf of a process-- For example, executing a system call or running a kernel thread. In process context, the current macro points to the associated task. Furthermore, because a process is coupled to the kernel in process context (because the process is connected to the kernel in the same way as the process above), process context can SleeP or otherwise invoke the scheduler.

Interrupt context, on the other hand, was not associated with a process. The current macro isn't relevant (although it points to the interrupted process). Without a backing process (because there is no process background), interrupt context cannot sleep-how would it ever reschedule? (or how to reschedule it again?) Therefore, cannot call certain functions from interrupt context. If A function sleeps, you cannot use it from your interrupt handler--this limits the functions so one can call from an Interrupt handler. (This is the limit on what functions can be used in an interrupt handler).

### How to find out if we are in an interrupt context?

in_interrupt()
====================

Header File: <linux/preempt.h>

To find out whether you are running in interrupt context or process context:
 - `in_interrupt()` returns non zero if the kernel is performing any type of interrupt handling.
 - `in_interrupt()` returns zero if the kernel is in process context.

You can use that macro to know if you can or not allocate memory, for example: 

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/slab.h>


#define SHARED_IRQ 12
static int irq = SHARED_IRQ, my_dev_id, irq_counter = 0;
module_param(irq, int, S_IRUGO);

void *alloc_mem(unsigned int size)
{
	// depending on the value of in_Interrupt()
	// we can allocate memory or not.
	if (in_interrupt()) {
		return kmalloc(size, GFP_ATOMIC);  // iGFP_ATOMIC n case of interrupt context
	} else {
		return kmalloc(size, GFP_KERNEL);  // GFP_KERNEL in case of process context
	}
}

static irqreturn_t my_interrupt(int irq, void *dev_id)
{
	void *mem = alloc_mem(1024);
	kfree(mem);
	return IRQ_NONE;	/* we return IRQ_NONE because we are just observing */
}

static int __init my_init(void)
{
	void *mem = alloc_mem(1024);
	kfree(mem);
	if (request_irq
	    (irq, my_interrupt, IRQF_SHARED, "my_interrupt", &my_dev_id)) {
		pr_info("Failed to reserve irq %d\n", irq);
		return -1;
	}
	pr_info("Successfully loading ISR handler\n");
	return 0;
}

static void __exit my_exit(void)
{
	synchronize_irq(irq);
	free_irq(irq, &my_dev_id);
	pr_info("Successfully unloading,  irq_counter = %d\n", irq_counter);
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

### Some debuging: printing the call stack 

Use the function `dump_stack();`:

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>

#define SHARED_IRQ 12
static int irq = SHARED_IRQ, my_dev_id, irq_counter = 0;
module_param(irq, int, S_IRUGO);

static irqreturn_t my_interrupt(int irq, void *dev_id)
{
	dump_stack();
	return IRQ_NONE;	/* we return IRQ_NONE because we are just observing */
}

static int __init my_init(void)
{
	if (request_irq
	    (irq, my_interrupt, IRQF_SHARED, "my_interrupt", &my_dev_id)) {
		pr_info("Failed to reserve irq %d\n", irq);
		return -1;
	}
	pr_info("Successfully loading ISR handler\n");
	return 0;
}

static void __exit my_exit(void)
{
	synchronize_irq(irq);
	free_irq(irq, &my_dev_id);
	pr_info("Successfully unloading,  irq_counter = %d\n", irq_counter);
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

### Can we use current macro inside interrupt handler?

It will point to the interrupted process.

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/sched.h>
#include <asm/current.h>

#define SHARED_IRQ 12
static int irq = SHARED_IRQ, my_dev_id, irq_counter = 0;
module_param(irq, int, S_IRUGO);

static irqreturn_t my_interrupt(int irq, void *dev_id)
{
	irq_counter++;
	pr_info("In the ISR: counter = %d\n", irq_counter);
	pr_info("current pid : %d , current process : %s\n",current->pid, current->comm);
	return IRQ_NONE;	/* we return IRQ_NONE because we are just observing */
}

static int __init my_init(void)
{
	if (request_irq
	    (irq, my_interrupt, IRQF_SHARED, "my_interrupt", &my_dev_id)) {
		pr_info("Failed to reserve irq %d\n", irq);
		return -1;
	}
	pr_info("Successfully loading ISR handler\n");
	return 0;
}

static void __exit my_exit(void)
{
	synchronize_irq(irq);
	free_irq(irq, &my_dev_id);
	pr_info("Successfully unloading,  irq_counter = %d\n", irq_counter);
}

MODULE_LICENSE("GPL");
module_init(my_init);
module_exit(my_exit);
```

### What happens if we sleep() in the interrupt handler?

It will crash :/



